# сортировка пузырьком по убыванию
start:      li      $t1, 0xf            # количество элементов, которое нужно пройти (меньше на 1, чтобы не выйти за пределы)

loop_ext:   move    $t0, $0             # итератор обнуляется, начинается очередной проход
#loop_int:   lw      $v0, 0x10010000($t0)         # загружаем из памяти элемент
#            lw      $s1, 0x10010004($t0)         # загружаем из памяти соседний элемент
loop_int:   lw      $v0, 0($t0)         # загружаем из памяти элемент
            addiu   $t2, $t0, 1		    # смещение для адреса соседнего элемента
            lw      $s1, ($t2)          # загружаем из памяти соседний элемент
            sltu    $t3, $v0, $s1       # t3 - флаг, если v0 < s1
            beq	    $t3, 1, swap        # если t3 истина, делаем обмен	
step_swap:  addiu   $t0, $t0, 1         # увеличиваем итератор
            beq     $t0, $t1, end_step  # если мы прошли весь массив, уменьшаем t1
            beq     $0, $0,  loop_int   # возвращаемся в начало цикла

end_step:   subu    $t1, $t1, 1         # уменьшаем t1 на 1
            beq     $t1, $0, end        # если t1 дошел до 0, заканчиваем работу
            beq     $0, $0,  loop_ext            # возвращаемся в начало цикла

swap:   move $t4, $v0   # t4 - временная переменная
        move $v0, $s1   # в регистр v0 запишем значение s1
        move $s1, $t4   # в регистр s1 запишем значение временной переменной
        sw   $v0, ($t0)
        sw   $s1, ($t2)
        beq  $0,  $0,  step_swap   # закончили обмен и возвращаемся в цикл    

end:    beq  $0,  $0,  end
       
            
